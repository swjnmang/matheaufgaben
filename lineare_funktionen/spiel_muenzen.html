<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF--8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Münzen-Sammler</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Roboto Mono', monospace;
        }
        canvas {
            background-color: #f0f9ff;
            border: 2px solid #a3a3a3;
            display: block;
            width: 100%;
            height: 100%;
        }
        .input-label {
            font-size: 1.2rem;
            font-weight: 700;
            color: #404040;
        }
        .input-field {
            font-family: 'Roboto Mono', monospace;
            background-color: #e5e5e5;
            color: #171717;
            border: 2px solid #a3a3a3;
            border-radius: 0.5rem;
            padding: 0.25rem 0.5rem;
            font-size: 1.2rem;
            width: 80px;
            text-align: center;
        }
        .ramp-control.active .input-field {
            background-color: #dcfce7; /* Greenish tint for active ramps */
        }
        .difficulty-btn.active {
            background-color: #1d4ed8;
            color: white;
        }
    </style>
</head>
<body class="bg-neutral-200 text-neutral-800 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl mx-auto bg-white rounded-xl shadow-lg p-6 text-center">
        <h1 class="text-3xl md:text-4xl font-bold text-neutral-700 mb-2">Münzen-Sammler</h1>
        <p class="text-neutral-500 mb-4">Baue Rampen, um die Münzen um das Hindernis in den Eimer zu leiten!</p>
        
        <div class="flex flex-col sm:flex-row justify-between items-center bg-neutral-100 p-3 rounded-lg mb-4 text-xl gap-4">
             <div>
                <span class="font-bold text-neutral-600">Punkte:</span>
                <span id="score" class="font-bold text-amber-500 ml-2">0</span>
             </div>
             <div class="flex gap-2">
                <button id="difficulty-normal" class="difficulty-btn active bg-neutral-300 hover:bg-neutral-400 text-neutral-800 font-bold py-2 px-4 rounded">Normal</button>
                <button id="difficulty-hard" class="difficulty-btn bg-neutral-300 hover:bg-neutral-400 text-neutral-800 font-bold py-2 px-4 rounded">Schwer</button>
             </div>
        </div>

        <div id="canvas-container" class="relative w-full" style="padding-bottom: 75%;"> <!-- 4:3 Aspect ratio -->
            <canvas id="gameCanvas" class="absolute top-0 left-0 w-full h-full rounded-lg"></canvas>
        </div>

        <!-- Steuerung -->
        <div id="controls-container" class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-4 p-4 bg-neutral-100 rounded-lg">
            <!-- Ramp controls will be generated here by JS -->
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const controlsContainer = document.getElementById('controls-container');
        const normalBtn = document.getElementById('difficulty-normal');
        const hardBtn = document.getElementById('difficulty-hard');
        const canvasContainer = document.getElementById('canvas-container');

        let score = 0;
        let coins = [];
        let ramps = [null, null, null, null];
        let bucket = {};
        let obstacle = null;
        let difficulty = 'normal';
        const RAMP_COLORS = ['#16a34a', '#2563eb', '#ca8a04', '#c026d3'];
        
        let gridRangeX = 10;
        let gridRangeY = 7.5;

        function resizeCanvas() {
            const containerWidth = canvasContainer.clientWidth;
            canvas.width = containerWidth;
            canvas.height = containerWidth * 0.75; // Maintain 4:3 aspect ratio
            gridRangeX = 10;
            gridRangeY = (gridRangeX * canvas.height) / canvas.width;
        }

        function toCanvasX(mathX) { return ((mathX + gridRangeX) / (2 * gridRangeX)) * canvas.width; }
        function toCanvasY(mathY) { return ((-mathY + gridRangeY) / (2 * gridRangeY)) * canvas.height; }

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = "#d4d4d4";
            ctx.lineWidth = 1;
            for (let i = Math.floor(-gridRangeX); i <= Math.ceil(gridRangeX); i++) {
                ctx.beginPath(); ctx.moveTo(toCanvasX(i), 0); ctx.lineTo(toCanvasX(i), canvas.height); ctx.stroke();
            }
            for (let i = Math.floor(-gridRangeY); i <= Math.ceil(gridRangeY); i++) {
                ctx.beginPath(); ctx.moveTo(0, toCanvasY(i)); ctx.lineTo(canvas.width, toCanvasY(i)); ctx.stroke();
            }
            ctx.strokeStyle = "#a3a3a3"; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, toCanvasY(0)); ctx.lineTo(canvas.width, toCanvasY(0)); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(toCanvasX(0), 0); ctx.lineTo(toCanvasX(0), canvas.height); ctx.stroke();
        }

        function drawBucket() {
            const x = toCanvasX(bucket.x);
            const y = toCanvasY(bucket.y);
            const w = bucket.width * (canvas.width / (2 * gridRangeX));
            ctx.fillStyle = "#525252";
            ctx.fillRect(x - w / 2, y, w, 30);
        }

        function drawObstacle() {
            if (!obstacle) return;
            const x = toCanvasX(obstacle.x);
            const y = toCanvasY(obstacle.y);
            const w = obstacle.width * (canvas.width / (2 * gridRangeX));
            const h = obstacle.height * (canvas.height / (2 * gridRangeY));
            ctx.fillStyle = "#dc2626"; // Red color for obstacle
            ctx.fillRect(x - w / 2, y - h / 2, w, h);
        }

        function drawRamps() {
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ramps.forEach((ramp, index) => {
                if (ramp === null) return;
                ctx.strokeStyle = RAMP_COLORS[index % RAMP_COLORS.length];
                ctx.beginPath();
                const y1 = ramp.m * (-gridRangeX) + ramp.b;
                const y2 = ramp.m * (gridRangeX) + ramp.b;
                ctx.moveTo(toCanvasX(-gridRangeX), toCanvasY(y1));
                ctx.lineTo(toCanvasX(gridRangeX), toCanvasY(y2));
                ctx.stroke();
            });
        }
        
        function spawnCoin() {
            coins.push({
                x: Math.random() * (gridRangeX * 1.8) - gridRangeX * 0.9,
                y: gridRangeY + 1,
                vy: 0.05 + Math.random() * 0.05,
                onRamp: null
            });
        }
        
        function updateAndDrawCoins() {
            const activeRamps = ramps.filter(r => r !== null);
            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];

                if (coin.onRamp) {
                    const currentRamp = coin.onRamp;
                    const direction = currentRamp.m > 0 ? -1 : 1;
                    coin.x += direction * 0.1;
                    coin.y = currentRamp.m * coin.x + currentRamp.b;
                } else {
                    coin.y -= coin.vy;
                    let hitRamp = null;
                    let highestRampY = -Infinity;
                    activeRamps.forEach(ramp => {
                        const rampY = ramp.m * coin.x + ramp.b;
                        if (coin.y >= rampY && (coin.y - coin.vy) < rampY) {
                            if (rampY > highestRampY) {
                                highestRampY = rampY;
                                hitRamp = ramp;
                            }
                        }
                    });

                    if (hitRamp) { coin.onRamp = hitRamp; coin.y = highestRampY; }
                }

                // Obstacle collision
                if (obstacle && !coin.onRamp) {
                    if (coin.x > obstacle.x - obstacle.width / 2 &&
                        coin.x < obstacle.x + obstacle.width / 2 &&
                        coin.y < obstacle.y + obstacle.height / 2 &&
                        coin.y > obstacle.y - obstacle.height / 2) {
                        coins.splice(i, 1);
                        continue;
                    }
                }

                if (coin.y <= bucket.y && Math.abs(coin.x - bucket.x) < bucket.width / 2) {
                    score += 10;
                    scoreEl.textContent = score;
                    coins.splice(i, 1);
                    continue;
                }

                if (coin.y < -gridRangeY - 2) { coins.splice(i, 1); continue; }

                ctx.fillStyle = "#f59e0b";
                ctx.beginPath();
                ctx.arc(toCanvasX(coin.x), toCanvasY(coin.y), 8, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function gameLoop() {
            drawGrid();
            drawBucket();
            drawObstacle();
            drawRamps();
            updateAndDrawCoins();
            requestAnimationFrame(gameLoop);
        }

        function setupControls() {
            controlsContainer.innerHTML = ''; // Clear existing controls
            const numControls = difficulty === 'hard' ? 4 : 2;
            controlsContainer.className = `mt-6 grid grid-cols-1 md:grid-cols-2 gap-4 p-4 bg-neutral-100 rounded-lg`;

            for (let i = 0; i < numControls; i++) {
                const controlEl = document.createElement('div');
                controlEl.className = 'ramp-control p-3 rounded-lg border-2';
                controlEl.style.borderColor = RAMP_COLORS[i];

                controlEl.innerHTML = `
                    <h3 class="font-bold text-lg mb-2" style="color: ${RAMP_COLORS[i]}">Rampe ${i + 1}</h3>
                    <div class="flex items-center gap-2 justify-center mb-3">
                        <span class="input-label">y=</span>
                        <input type="number" class="m-input input-field" step="0.1" data-index="${i}">
                        <span class="input-label">x+</span>
                        <input type="number" class="b-input input-field" step="0.5" data-index="${i}">
                    </div>
                    <div class="flex gap-2 justify-center">
                         <button class="build-button bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-2 px-4 rounded text-md w-full" data-index="${i}">Bauen</button>
                         <button class="clear-button bg-rose-500 hover:bg-rose-600 text-white font-bold py-2 px-4 rounded text-md w-full" data-index="${i}" style="display: none;">Löschen</button>
                    </div>
                `;
                controlsContainer.appendChild(controlEl);

                const mInput = controlEl.querySelector('.m-input');
                const bInput = controlEl.querySelector('.b-input');
                const buildBtn = controlEl.querySelector('.build-button');
                const clearBtn = controlEl.querySelector('.clear-button');

                buildBtn.addEventListener('click', () => {
                    const m = parseFloat(mInput.value);
                    const b = parseFloat(bInput.value);
                    if (!isNaN(m) && !isNaN(b)) {
                        ramps[i] = { m, b };
                        controlEl.classList.add('active');
                        buildBtn.textContent = 'Ändern';
                        clearBtn.style.display = 'inline-block';
                    }
                });

                clearBtn.addEventListener('click', () => {
                    ramps[i] = null;
                    controlEl.classList.remove('active');
                    buildBtn.textContent = 'Bauen';
                    clearBtn.style.display = 'none';
                    mInput.value = '';
                    bInput.value = '';
                });
            }
        }
        
        function resetGame() {
            score = 0;
            scoreEl.textContent = '0';
            coins = [];
            ramps = [null, null, null, null];
            setupControls();
            setupNewRound();
        }

        function setupNewRound() {
            bucket = {
                x: Math.random() * 12 - 6,
                y: -gridRangeY + 0.5,
                width: 3
            };

            if (difficulty === 'hard') {
                obstacle = {
                    x: bucket.x,
                    y: bucket.y + 2.5,
                    width: 5,
                    height: 1
                };
            } else {
                obstacle = null;
            }
        }
        
        normalBtn.addEventListener('click', () => {
            difficulty = 'normal';
            normalBtn.classList.add('active');
            hardBtn.classList.remove('active');
            resetGame();
        });

        hardBtn.addEventListener('click', () => {
            difficulty = 'hard';
            hardBtn.classList.add('active');
            normalBtn.classList.remove('active');
            resetGame();
        });
        
        // Spielstart
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        setupControls();
        setupNewRound();
        setInterval(spawnCoin, 400);
        gameLoop();

    </script>
</body>
</html>

