<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nullstellen-Fänger</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Roboto' Mono', monospace;
            cursor: none; /* Wir zeichnen einen eigenen Cursor (den Eimer) */
        }
        canvas {
            background-color: #f1f5f9;
            border: 2px solid #94a3b8;
        }
        .equation-box {
            background-color: #1e293b;
            color: #e2e8f0;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            font-size: 1.75rem;
            font-weight: 700;
            letter-spacing: 2px;
            border: 2px solid #334155;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body class="bg-slate-200 text-slate-800 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl mx-auto bg-white rounded-xl shadow-lg p-6 text-center">
        <h1 class="text-3xl md:text-4xl font-bold text-slate-700 mb-2">Nullstellen-Fänger</h1>
        <p class="text-slate-500 mb-4">Berechne zuerst die Nullstellen schriftlich! Platziere dann die Eimer an den richtigen Positionen.</p>

        <div class="flex justify-between items-center bg-slate-100 p-3 rounded-lg mb-4 text-lg">
            <div>
                <span class="font-bold text-slate-600">Punkte:</span>
                <span id="score" class="font-bold text-indigo-600">0</span>
            </div>
            <div id="equation" class="equation-box">y = x² - 4</div>
            <div>
                 <span class="font-bold text-slate-600">Treffer:</span>
                 <span id="feedback" class="font-bold text-slate-600">-</span>
            </div>
        </div>

        <div class="relative w-full" style="padding-bottom: 62.5%;"> <!-- 16:10 Aspect ratio -->
            <canvas id="gameCanvas" class="absolute top-0 left-0 w-full h-full rounded-lg"></canvas>
            <div id="gameOverlay" class="absolute top-0 left-0 w-full h-full bg-slate-900 bg-opacity-80 text-white flex flex-col justify-center items-center rounded-lg">
                <h2 id="overlayTitle" class="text-4xl font-bold mb-4">Bereit?</h2>
                <p id="overlayText" class="mb-6 text-lg">Platziere 2 Eimer mit der Maus und klicke.</p>
                <button id="startButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-8 rounded-lg text-xl shadow-md transition-transform transform hover:scale-105">Spiel starten</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const equationEl = document.getElementById('equation');
        const feedbackEl = document.getElementById('feedback');
        const startButton = document.getElementById('startButton');
        const gameOverlay = document.getElementById('gameOverlay');

        canvas.width = 1000;
        canvas.height = 625;

        let score = 0;
        let gameOver = true;
        let isAnimating = false;
        
        let currentFunction = {};
        let buckets = [];
        let ghostBucket = {};
        let balls = [];
        let trailPoints = [];

        const gridRangeX = 10;
        const gridRangeY = (gridRangeX * canvas.height) / canvas.width;

        function fromCanvasX(canvasX) {
            return (canvasX / canvas.width) * (2 * gridRangeX) - gridRangeX;
        }
        function toCanvasX(mathX) {
            return ((mathX + gridRangeX) / (2 * gridRangeX)) * canvas.width;
        }
        function toCanvasY(mathY) {
            return ((-mathY + gridRangeY) / (2 * gridRangeY)) * canvas.height;
        }

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = "#cbd5e1";
            ctx.lineWidth = 1;
            ctx.font = "14px 'Roboto Mono'";
            ctx.fillStyle = "#64748b";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            for (let i = -gridRangeX; i <= gridRangeX; i++) {
                ctx.beginPath();
                ctx.moveTo(toCanvasX(i), 0);
                ctx.lineTo(toCanvasX(i), canvas.height);
                ctx.stroke();
                if (i !== 0) {
                   ctx.fillText(i, toCanvasX(i), toCanvasY(0) + 15);
                }
            }
            for (let i = Math.floor(-gridRangeY); i <= Math.ceil(gridRangeY); i++) {
                ctx.beginPath();
                ctx.moveTo(0, toCanvasY(i));
                ctx.lineTo(canvas.width, toCanvasY(i));
                ctx.stroke();
                 if (i !== 0) {
                    ctx.fillText(i, toCanvasX(0) - 20, toCanvasY(i));
                }
            }

            ctx.strokeStyle = "#475569";
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, toCanvasY(0)); ctx.lineTo(canvas.width, toCanvasY(0)); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(toCanvasX(0), 0); ctx.lineTo(toCanvasX(0), canvas.height); ctx.stroke();
        }

        function drawBucket(bucket, isGhost = false) {
            if (typeof bucket.x === 'undefined') return;
            const canvasX = toCanvasX(bucket.x);
            const y = toCanvasY(0);
            const width = toCanvasX(bucket.width) - toCanvasX(0);
            
            ctx.fillStyle = isGhost ? "rgba(100, 116, 139, 0.5)" : "#64748b";
            ctx.beginPath();
            ctx.moveTo(canvasX - width / 2, y);
            ctx.lineTo(canvasX - width * 0.4, y + 25);
            ctx.lineTo(canvasX + width * 0.4, y + 25);
            ctx.lineTo(canvasX + width / 2, y);
            ctx.fill();
        }

        function generateQuadraticFunction() {
            // 'a' ist jetzt ein fester ganzzahliger Wert.
            const a = -1;
            let x1, x2;
            do {
                // Nullstellen werden jetzt im Bereich von -9 bis 9 generiert.
                x1 = Math.floor(Math.random() * 19) - 9; 
                x2 = Math.floor(Math.random() * 19) - 9;
            } while (x1 === x2 && Math.random() < 0.5); // Nur die Prüfung auf doppelte Nullstellen bleibt.

            const b = -a * (x1 + x2);
            const c = a * x1 * x2;
            
            // Formatierung für ganzzahlige Werte
            let a_text = a === -1 ? "-" : (a === 1 ? "" : `${a}`);
            let b_text = "";
            if (b !== 0) {
                if (Math.abs(b) === 1) {
                    b_text = b > 0 ? " + x" : " - x";
                } else {
                    b_text = b > 0 ? ` + ${b}x` : ` - ${Math.abs(b)}x`;
                }
            }
            
            let c_text = c === 0 ? "" : (c > 0 ? ` + ${c}` : ` - ${Math.abs(c)}`);

            equationEl.innerHTML = `y = ${a_text}x²${b_text}${c_text}`;
            
            return { a, b, c, roots: [x1, x2].sort((n1, n2) => n1 - n2) };
        }

        function drawBalls() {
            if (balls.length === 0) return;
            const { a, b, c } = currentFunction;

            balls.forEach(ball => {
                const y = a * ball.x * ball.x + b * ball.x + c;
                ctx.fillStyle = "#0ea5e9";
                ctx.beginPath();
                ctx.arc(toCanvasX(ball.x), toCanvasY(y), 10, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawTrail() {
            ctx.fillStyle = "rgba(14, 165, 233, 0.3)";
            trailPoints.forEach(p => {
                ctx.beginPath();
                ctx.arc(toCanvasX(p.x), toCanvasY(p.y), 4, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function animateBalls() {
            if (!isAnimating) return;

            // Update ball positions
            balls.forEach(ball => {
                ball.x += ball.direction * 0.05; // Geschwindigkeit
            });

            // Add current positions to trail
            const { a, b, c } = currentFunction;
            balls.forEach(ball => {
                const y = a * ball.x * ball.x + b * ball.x + c;
                trailPoints.push({ x: ball.x, y: y });
            });

            // Redraw everything
            drawGrid();
            buckets.forEach(b => drawBucket(b, false));
            drawTrail();
            drawBalls();

            // Check if animation is finished (one ball is enough)
            if (Math.abs(balls[0].x) > gridRangeX + 1) {
                isAnimating = false;
                drawGrid();
                buckets.forEach(b => drawBucket(b, false));
                drawTrail(); // Draw final trail state
                checkHits();
                return;
            }

            requestAnimationFrame(animateBalls);
        }

        function checkHits() {
            const { roots } = currentFunction;
            const bucketWidth = ghostBucket.width;
            
            const placedRoots = buckets.map(b => b.x).sort((n1, n2) => n1 - n2);

            if (placedRoots.length < 2) { // Failsafe
                feedbackEl.textContent = "2 Eimer nötig!";
                feedbackEl.className = "font-bold text-rose-500";
                setTimeout(nextRound, 2000);
                return;
            }

            const hit1 = Math.abs(placedRoots[0] - roots[0]) < bucketWidth / 2;
            const hit2 = Math.abs(placedRoots[1] - roots[1]) < bucketWidth / 2;

            let hitsCount = 0;
            if (hit1) hitsCount++;
            if (hit2) hitsCount++;

            if (hitsCount === 2) {
                feedbackEl.textContent = "Volltreffer! +10";
                feedbackEl.className = "font-bold text-emerald-500";
                score += 10;
            } else if (hitsCount === 1) {
                feedbackEl.textContent = "Ein Treffer! +5";
                feedbackEl.className = "font-bold text-sky-500";
                score += 5;
            } else {
                feedbackEl.textContent = "Daneben!";
                feedbackEl.className = "font-bold text-rose-500";
            }
            
            scoreEl.textContent = score;
            setTimeout(nextRound, 2000);
        }

        function gameLoop() {
            if (gameOver || isAnimating) return;
            drawGrid();
            
            buckets.forEach(b => drawBucket(b, false));
            if(buckets.length < 2) drawBucket(ghostBucket, true);

            requestAnimationFrame(gameLoop);
        }

        function nextRound() {
            isAnimating = false;
            balls = [];
            trailPoints = [];
            buckets = [];
            feedbackEl.textContent = "-";
            feedbackEl.className = "font-bold text-slate-600";
            currentFunction = generateQuadraticFunction();
            gameLoop();
        }

        function startGame() {
            gameOver = false;
            score = 0;
            scoreEl.textContent = '0';
            ghostBucket = { x: 0, width: 1.2 };
            gameOverlay.style.display = 'none';
            nextRound();
        }

        startButton.addEventListener('click', startGame);

        canvas.addEventListener('mousemove', e => {
            if (gameOver || isAnimating || buckets.length >= 2) return;
            const rect = canvas.getBoundingClientRect();
            ghostBucket.x = fromCanvasX(e.clientX - rect.left);
        });

        canvas.addEventListener('click', () => {
            if (gameOver || isAnimating || buckets.length >= 2) return;
            
            buckets.push({ x: ghostBucket.x, width: ghostBucket.width });

            if (buckets.length === 2) {
                isAnimating = true;
                const { a, b } = currentFunction;
                const vertexX = -b / (2 * a);

                balls = [
                    { x: vertexX, direction: -1 },
                    { x: vertexX, direction: 1 }
                ];
                trailPoints = [];
                
                animateBalls();
            }
        });

        drawGrid();
    </script>
</body>
</html>

